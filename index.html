<!DOCTYPE html>
<html lang="pl">
<head>
<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#667eea">
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function () {
      navigator.serviceWorker.register('service-worker.js').catch(function (err) {
        console.error('Service worker registration failed:', err);
      });
    });
  }
</script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Karuzela z trzema kołami</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      padding: 0;
      background: linear-gradient(135deg, #7788ee 0%, #8660a8 100%);
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      overflow: auto;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
      position: relative;
    }

    /* Wrapper dla zawartości */
    .content-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      width: 100%;
      padding: 40px 20px;
      position: relative;
    }

    h1 {
      margin: 0;
      margin-bottom: 30px;
      font-size: clamp(28px, 5vw, 42px);
      font-weight: 700;
      color: white;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
      letter-spacing: -0.5px;
      position: relative;
      z-index: 10;
    }

    /* ===== NOWE STYLE DLA MOBILE ===== */
    /* Nawigacja zakładek dla mobile */
    .mobile-nav {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      box-shadow: 0 -2px 10px rgba(0,0,0,0.1);
      z-index: 1000;
    }

    .mobile-nav-tabs {
      display: flex;
      justify-content: space-around;
      padding: 8px 0;
    }

    .mobile-nav-tab {
      flex: 1;
      padding: 10px;
      text-align: center;
      background: none;
      border: none;
      font-size: 12px;
      color: #666;
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
    }

    .mobile-nav-tab.active {
      color: #667eea;
      font-weight: 600;
    }

    .mobile-nav-tab.active::after {
      content: '';
      position: absolute;
      top: 0;
      left: 20%;
      right: 20%;
      height: 3px;
      background: #667eea;
      border-radius: 0 0 3px 3px;
    }

    .mobile-nav-tab .icon {
      font-size: 20px;
      display: block;
      margin-bottom: 4px;
    }

    /* Styl dla przycisku historii podczas przeciągania */
    .mobile-nav-tab.drag-over {
      background: rgba(102, 126, 234, 0.2);
      transform: scale(1.05);
    }

    /* Data i czas dla mobile */
    .mobile-datetime {
      display: none;
      background: rgba(255, 255, 255, 0.9);
      padding: 8px 12px;
      border-radius: 15px;
      margin: 10px 0 15px 10px;
      align-self: flex-start;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .mobile-datetime #mobile-date {
      font-size: 14px;
      color: #666;
      margin-bottom: 2px;
	  font-weight: bold;
    }

    .mobile-datetime #mobile-time {
      font-size: 16px;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Przyciski akcji dla mobile */
    .mobile-action-buttons {
      display: flex;
      gap: 5px;
    }

    .mobile-action-btn {
      padding: 8px 12px;
      background: none;
      border: 1px solid #ddd;
      border-radius: 20px;
      font-size: 11px;
      color: #666;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 3px;
    }

    .mobile-action-btn:active {
      background: rgba(0,0,0,0.05);
      transform: scale(0.95);
    }

    .mobile-action-btn.save {
      background: #667eea;
      color: white;
      border-color: #667eea;
      font-weight: 600;
    }

    /* Widok mobilny - lista kół */
    .mobile-circles-view {
      display: none;
      width: 100%;
      padding-bottom: 80px; /* Miejsce na nawigację */
    }

    .mobile-circle-container {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 20px;
      margin: 10px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    .mobile-circle-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .mobile-circle-title {
      font-size: 18px;
      font-weight: 600;
      color: #2c3e50;
    }

    .mobile-add-task-btn {
      background: #667eea;
      color: white;
      border: none;
      border-radius: 20px;
      padding: 8px 16px;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .mobile-add-task-btn:active {
      transform: scale(0.95);
    }

    .mobile-task-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .mobile-task-item {
      display: flex;
      align-items: flex-start;
      background: rgba(255, 255, 255, 0.8);
      padding: 12px;
      border-radius: 12px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.05);
      transition: all 0.3s ease;
      position: relative;
    }

    .mobile-task-item:active {
      background: rgba(255, 255, 255, 0.95);
      transform: scale(0.98);
    }

    .mobile-task-checkbox {
      width: 22px;
      height: 22px;
      margin-right: 12px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: bold;
      user-select: none;
      border-radius: 6px;
      background: rgba(255,255,255,0.8);
      border: 2px solid #333;
      color: #333;
      transition: all 0.2s ease;
      flex-shrink: 0;
    }

    .mobile-task-text {
      flex-grow: 1;
      font-size: 14px;
      line-height: 1.5;
      color: #2c3e50;
      padding: 2px 8px;
      border-radius: 6px;
      outline: none;
      transition: background 0.2s ease;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    .mobile-task-text:focus {
      background: rgba(255,255,255,0.6);
    }

    /* Mobile history view */
    .mobile-history-view {
      display: none;
      width: 100%;
      padding: 20px;
      padding-bottom: 80px;
    }

    .mobile-history-container {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }

    /* Ukryj desktop elementy na mobile */
    @media (max-width: 768px) {
      h1 {
        font-size: 24px;
        margin-bottom: 5px;
        text-align: center;
      }

      .carousel {
        display: none !important;
      }

      .history-section {
        display: none !important;
      }

      .content-wrapper {
        padding: 20px 0;
        justify-content: flex-start;
        min-height: 100vh;
      }

      .mobile-nav {
        display: block;
      }

      .mobile-circles-view {
        display: block;
      }

      .mobile-datetime {
        display: block;
      }

      .buttons-container {
        display: none !important;
      }

      .datetime-container {
        display: none;
      }

      /* Drag handle dla mobile */
      .mobile-drag-handle {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #999;
        cursor: move;
        touch-action: none;
      }

      .mobile-task-item.dragging {
        opacity: 0.5;
        transform: scale(0.95);
      }

      /* Animacja statusu checkbox dla mobile */
      .mobile-task-checkbox[data-status="1"]::before {
        content: "";
        display: block;
        position: absolute;
        top: -10px;
        left: -10px;
        right: -10px;
        bottom: -10px;
        border: 2px solid #2c6cf4;
        border-radius: 12px;
        pointer-events: none;
        animation: stretch-visible 1.3s infinite ease-in-out;
        opacity: 0.9;
      }

      .mobile-task-checkbox[data-status="2"] {
        color: #27ae60;
        border-color: #27ae60;
      }

      .mobile-task-checkbox[data-status="3"] {
        color: #e74c3c;
        border-color: #e74c3c;
      }
    }

    /* ===== KONIEC NOWYCH STYLÓW DLA MOBILE ===== */

    /* Specjalne ustawienia dla telefonu */
    @media (max-width: 768px) {
      .content-wrapper {
        justify-content: flex-start;
        padding-top: 60px;
        min-height: auto;
        padding-bottom: 60px;
      }
      
      h1 {
        margin-bottom: 40px;
        margin-top: 0;
      }
    }

    .carousel {
      position: relative;
      width: min(85vw, 900px);
      height: min(85vw, 900px);
      cursor: grab;
      touch-action: none;
      margin-bottom: 40px;
    }

    .carousel:active {
      cursor: grabbing;
    }

    .circle {
      position: absolute;
      width: min(50vw, 440px);
      height: min(50vw, 440px);
      border-radius: 50%;
      color: #333;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      font-size: clamp(13px, 2.2vw, 16px);
      font-weight: normal;
      text-align: left;
      padding: min(6vw, 35px);
      left: 50%;
      top: 50%;
      transform-origin: center center;
      user-select: none;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.2);
      transition: box-shadow 0.3s ease;
      touch-action: pan-y;
    }

    .circle:hover {
      box-shadow: 0 12px 40px rgba(0,0,0,0.3);
    }

    /* Historia zadań */
    .history-section {
      width: min(90vw, 1000px);
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(10px);
      border-radius: 20px;
      padding: 30px;
      margin-top: 20px;
      margin-bottom: 40px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      min-height: 200px;
      max-height: 400px;
      overflow-y: auto;
    }

    .history-title {
      font-size: clamp(20px, 3vw, 24px);
      font-weight: 600;
      color: white;
      margin-bottom: 20px;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.2);
    }

    .history-content {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .history-empty {
      text-align: center;
      color: rgba(255, 255, 255, 0.6);
      font-style: italic;
      padding: 40px;
    }

    .history-task {
      display: flex;
      align-items: flex-start;
      background: rgba(255, 255, 255, 0.25);
      padding: 10px 15px;
      border-radius: 10px;
      transition: all 0.2s ease;
      cursor: move;
      position: relative;
      width: 90%; 
    }

    .history-task:hover {
      background: rgba(255, 255, 255, 0.35);
      transform: translateX(5px) scale(1.05); 
      z-index: 10;
    }

    .history-task .checkbox {
      margin-right: 10px;
    }

    .history-task .task-text {
      color: #2c3e50;
      flex-grow: 1;
    }

    .history-task .timestamp {
      font-size: 11px;
      color: rgba(44, 62, 80, 0.6);
      margin-left: 40px;
      white-space: nowrap;
    }

    /* Niestandardowy scrollbar dla historii */
    .history-section::-webkit-scrollbar {
      width: 8px;
    }

    .history-section::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.1);
      border-radius: 4px;
    }

    .history-section::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.3);
      border-radius: 4px;
    }

    .history-section::-webkit-scrollbar-thumb:hover {
      background: rgba(255,255,255,0.4);
    }

    /* Nowy kontener na listę zadań wewnątrz koła */
    .task-list-container {
      flex-grow: 1;
      overflow-y: auto;
      overflow-x: hidden;
      max-height: 86%;
      width: 100%;
      padding: 0 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      position: relative;
    }

    /* Niestandardowy scrollbar dla kontenera zadań (aby był bardziej dyskretny) */
    .task-list-container::-webkit-scrollbar {
      width: 6px;
	  background: transparent;
    }

    .task-list-container::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.05);
      border-radius: 4px;
    }

    .task-list-container::-webkit-scrollbar-thumb {
      background: transparent;
      border-radius: 8px;
	  transition: background 0.3s ease;
    }

    .task-list-container::-webkit-scrollbar-thumb:hover {
      background: rgba(0,0,0,0.25);
    }
	
	.task-list-container:hover::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.1);
    }

    .circle-title {
      font-weight: 700;
      font-size: clamp(14px, 2.5vw, 18px);
      margin-bottom: 15px;
      font-family: 'Georgia', 'Times New Roman', serif;
      font-style: italic;
      align-self: center;
      color: #2c3e50;
      text-shadow: 1px 1px 2px rgba(255,255,255,0.5);
      margin-top: -10px;
    }

    .task-line {
      display: flex;
      align-items: flex-start;
      width: auto;
      min-width: 60px;
      max-width: 92%;
      margin-bottom: 8px;
      padding: 6px 8px;
      border-radius: 8px;
      background: rgba(255,255,255,0.3);
      /* ZMIANA: Usunięto 'width' z 'all', aby zmiana szerokości nie była animowana */
      transition: background 0.3s ease, transform 0.3s ease, box-shadow 0.3s ease;
      cursor: move;
      height: auto;
      position: relative;
      transform-origin: center center;
      word-wrap: break-word;
    }

    .task-line:hover {
      background: rgba(255,255,255,0.4);
      transform: scale(1.10);
      z-index: 20;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .task-line.focused {
      transform: scale(1.08);
      z-index: 20;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.45);
    }

    .task-line.dragging {
      opacity: 0.5;
      transform: scale(0.95);
    }

    .checkbox {
      width: 16px;
      height: 16px;
      margin-right: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      transform: translateY(0);
      font-weight: bold;
      user-select: none;
      border-radius: 4px;
      background: rgba(255,255,255,0.5);
      border: 1.5px solid #333;
      color: #333;
      transition: all 0.2s ease;
      flex-shrink: 0;
      margin-top: 1px;
      position: relative;
    }
    
    .checkbox[data-status="2"],
    .checkbox[data-status="3"] {
      line-height: 0.1;
      font-size: 26px;
      transform: translateY(-1px);
    }

    .checkbox[data-status="1"]::before {
      content: "";
      display: block;
      position: absolute;
      top: -8px;
      left: -8px;
      right: -8px;
      bottom: -8px;
      border: 2px solid #2c6cf4;
      border-radius: 14px 18px 15px 17px;
      pointer-events: none;
      animation: stretch-visible 1.3s infinite ease-in-out;
      opacity: 0.9;
      transform-origin: center center;
      will-change: transform;
    }

    .checkbox[data-status="1"] {
      background: rgba(255,255,255,0.6);
    }

    @keyframes stretch-visible {
      0%   { transform: scaleX(1) scaleY(1); }
      25%  { transform: scaleX(1.08) scaleY(1.04); }
      50%  { transform: scaleX(1.03) scaleY(1.06); }
      75%  { transform: scaleX(1.09) scaleY(1.02); }
      100% { transform: scaleX(1) scaleY(1); }
    }

    .checkbox[data-status="2"] {
      color: #27ae60;
    }

    .checkbox[data-status="3"] {
      color: #e74c3c;
    }

    .checkbox:hover {
      background: rgba(255,255,255,0.7);
      transform: scale(1.1);
    }

    .checkbox:active {
      transform: scale(0.95);
    }

    .task-text {
      flex-grow: 1;
      outline: none;
      border: none;
      background: transparent;
      font-family: 'Segoe Print', 'Segoe UI Emoji', serif;
      font-style: normal;
      font-size: clamp(11px, 1.5vw, 13px);
      cursor: text;
      color: #2c3e50;
      line-height: 1.4;
      word-wrap: break-word;
      word-break: break-word;
      overflow-wrap: anywhere;
      hyphens: auto;
      -webkit-hyphens: auto;
      -moz-hyphens: auto;
      -ms-hyphens: auto;
      min-width: 0;
      flex-basis: 0;
      white-space: normal;
      max-width: 100%;
	  min-width: 95%;
    }

    /* Kontener na przyciski */
    .buttons-container {
      position: fixed;
      right: 20px;
      top: 20px;
      display: flex;
      gap: 10px;
      align-items: center;
      z-index: 10;
    }

    .save-button {
      padding: 12px 24px;
      font-size: clamp(14px, 2.5vw, 16px);
      font-weight: 600;
      cursor: pointer;
      background: white;
      color: #667eea;
      border: none;
      border-radius: 25px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }

    .save-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.3);
    }

    .save-button:active {
      transform: translateY(0);
    }

    /* Przyciski eksportu i importu */
    .export-button, .import-button {
      padding: 8px 16px;
      font-size: clamp(12px, 2vw, 14px);
      font-weight: 500;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.8);
      color: #555;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 20px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .export-button:hover, .import-button:hover {
      background: rgba(255, 255, 255, 0.95);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    }

    .export-button:active, .import-button:active {
      transform: translateY(0);
    }

    /* Ukryty input do importu */
    #import-input {
      display: none;
    }

    /* Wskazówka dla użytkownika */
    .hint {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      font-size: clamp(12px, 2vw, 14px);
      opacity: 0;
      animation: fadeInOut 5s ease-in-out;
      pointer-events: none;
      z-index: 1000;
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; }
      20%, 80% { opacity: 1; }
    }

    .circle:nth-child(1) {
      background: linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%);
    }

    .circle:nth-child(2) {
      background: linear-gradient(135deg, #ffd93d 0%, #f9ca24 100%);
    }

    .circle:nth-child(3) {
      background: linear-gradient(135deg, #6bcf7f 0%, #4cd137 100%);
    }

    /* Responsywność dla małych ekranów */
    @media (max-width: 480px) {
      body {
        padding: 10px;
      }

      .content-wrapper {
        padding-top: 40px;
        padding-bottom: 40px;
      }

      .carousel {
        width: 90vw;
        height: 90vw;
        margin-bottom: 30px;
      }

      .circle {
        width: 60vw;
        height: 60vw;
        padding: min(5vw, 25px);
      }

      .buttons-container {
        right: 10px;
        top: 10px;
        flex-direction: column-reverse;
        gap: 5px;
      }

      .save-button {
        padding: 8px 16px;
      }

      .export-button, .import-button {
        padding: 6px 12px;
        font-size: 12px;
      }

      .task-line {
        padding: 5px 6px;
        margin-bottom: 6px;
        min-width: 50px;
      }

      .checkbox {
        width: 18px;
        height: 18px;
        font-size: 14px;
        margin-right: 8px;
      }

      .checkbox[data-status="2"],
      .checkbox[data-status="3"] {
        font-size: 16px;
      }

      .task-text {
        font-size: 12px;
      }

      .circle-title {
        font-size: 16px;
        margin-top: -5px;
      }

      .history-section {
        padding: 20px;
        margin-top: 15px;
      }

      .history-title {
        font-size: 18px;
        margin-bottom: 15px;
      }
      
      .task-list-container {
        max-width: calc(100% - 20px);
      }
    }

    /* Animacja pojawiania się */
    .circle {
      animation: popIn 0.5s ease-out backwards;
    }

    .circle:nth-child(1) { animation-delay: 0.1s; }
    .circle:nth-child(2) { animation-delay: 0.2s; }
    .circle:nth-child(3) { animation-delay: 0.3s; }

    @keyframes popIn {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 0;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 1;
      }
    }

    /* Efekt świecenia dla aktywnego koła */
    .circle.active {
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
    }

    /* Data i czas */
    .datetime-container {
      position: fixed;
      left: 20px;
      top: 20px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px 20px;
      border-radius: 20px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.2);
      z-index: 10;
      text-align: center;
      min-width: 140px;
    }

    #current-date {
      font-size: clamp(15px, 2vw, 19px);
      font-weight: 600;
      color: #2c3e50;
      margin-bottom: 4px;
    }

    #current-time {
      font-size: clamp(16px, 3vw, 22px);
      font-weight: 700;
      color: #2c3e50;
      letter-spacing: 1px;
    }

    /* Responsywność dla małych ekranów - data i czas */
    @media (max-width: 480px) {
      .datetime-container {
        left: 10px;
        top: auto;
        bottom: 10px;
        padding: 8px 16px;
        min-width: 120px;
      }
      
      #current-date {
        font-size: 11px;
        margin-bottom: 2px;
      }
      
      #current-time {
        font-size: 16px;
      }
    }

    /* Dodatkowy styl dla szerszej zawartości */
    @media (min-width: 1200px) {
      .content-wrapper {
        max-width: 1400px;
        margin: 0 auto;
      }
    }

    /* Efekt świecenia dla historii przy przeciąganiu */
    .history-section.drag-over {
      box-shadow: 0 0 30px rgba(255,255,255,0.4);
      background: rgba(255, 255, 255, 0.25);
    }
  </style>
</head>
<body>
  <div class="content-wrapper">
    <h1>Karuzela zadań</h1>
    
    <!-- Data i czas dla mobile -->
    <div class="mobile-datetime">
      <div id="mobile-date"></div>
      <div id="mobile-time"></div>
    </div>
    
    <div class="datetime-container">
      <div id="current-date"></div>
      <div id="current-time"></div>
    </div>
    <div id="carousel" class="carousel"></div>
    
    <!-- Sekcja historii zadań -->
    <div class="history-section">
      <div class="history-title">📚 Historia zadań</div>
      <div class="history-content" id="history-content">
        <div class="history-empty">Przeciągnij tutaj zadania, aby przenieść je do historii</div>
      </div>
    </div>
    
    <!-- NOWY: Widok mobilny -->
    <div class="mobile-circles-view" id="mobile-circles-view">
      <!-- Koła będą generowane tutaj przez JavaScript -->
    </div>
    
    <div class="mobile-history-view" id="mobile-history-view">
      <div class="mobile-history-container">
        <div class="history-title">📚 Historia zadań</div>
        <div class="history-content" id="mobile-history-content">
          <div class="history-empty">Brak zadań w historii</div>
        </div>
      </div>
    </div>
    
    <!-- NOWA: Nawigacja mobilna -->
    <nav class="mobile-nav">
      <div class="mobile-nav-tabs">
        <button class="mobile-nav-tab active" data-view="tasks">
          <span class="icon">📋</span>
          <span>Zadania</span>
        </button>
        <button class="mobile-nav-tab" data-view="history" id="mobile-history-tab">
          <span class="icon">📚</span>
          <span>Historia</span>
        </button>
        <div class="mobile-action-buttons">
          <button class="mobile-action-btn save" onclick="saveData()">
            💾 Zapisz
          </button>
          <button class="mobile-action-btn" onclick="exportData()">
            ⬇ Eksport
          </button>
          <button class="mobile-action-btn" onclick="document.getElementById('import-input').click()">
            ⬆ Import
          </button>
        </div>
      </div>
    </nav>
    
    <div class="buttons-container">
      <button class="export-button" onclick="exportData()">
        <span>⬇</span> Eksport
      </button>
      <button class="import-button" onclick="document.getElementById('import-input').click()">
        <span>⬆</span> Import
      </button>
      <input type="file" id="import-input" accept=".json" onchange="importData(event)">
      <button class="save-button" onclick="saveData()">💾 Zapisz</button>
    </div>
    <div class="hint">Podwójne kliknięcie aby dodać zadanie • Przeciągnij między kołami</div>
  </div>

  <script>
    const carousel = document.getElementById("carousel");
    const historyContent = document.getElementById("history-content");
    const historySection = document.querySelector(".history-section");
    const isMobile = window.innerWidth <= 768;

    const radius = isMobile ? 
      Math.min(window.innerWidth * 0.35, 180) - 3 : 
      253 - 3;
    
    let angle = Math.PI / 2 + Math.PI / 6;
    let velocity = 0;
    let isDragging = false;
    let lastTheta = 0;
    let frame;
    let lastTime = 0;
    let isModified = false;
    let draggedTask = null;
    const longPressDuration = 700;
    let longPressTimer;

    // Zmienne dla przeciągania tła na mobile
    let isBackgroundDragging = false;
    let startX = 0;
    let startY = 0;
    let scrollLeft = 0;
    let scrollTop = 0;

    const titles = ["🔥 Pilne", "📋 Do zrobienia", "💭 Może później"];
    const defaultTasks = [
      ["Zakończyć projekt", "Napisać raport"],
      ["Zrobić zakupy"],
      ["Przeczytać książkę"]
    ];

    const saved = JSON.parse(localStorage.getItem("taskData"));
    const taskData = saved || defaultTasks.map(group => group.map(text => ({ text, status: 0 })));
    
    const savedHistory = JSON.parse(localStorage.getItem("taskHistory")) || [];

    // ===== NOWE FUNKCJE DLA MOBILE =====
    let currentMobileView = 'tasks';
    let mobileDraggedTask = null;
    let mobileDraggedFrom = null;

    function initMobileView() {
      if (!isMobile) return;

      const mobileCirclesView = document.getElementById('mobile-circles-view');
      const mobileHistoryView = document.getElementById('mobile-history-view');
      
      // Twórz mobilne koła
      taskData.forEach((circleData, index) => {
        const container = document.createElement('div');
        container.className = 'mobile-circle-container';
        container.dataset.circleIndex = index;
        
        // Ustawienie kolorów tła zgodnie z oryginalnymi kołami
        const colors = [
          'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)',
          'linear-gradient(135deg, #ffd93d 0%, #f9ca24 100%)',
          'linear-gradient(135deg, #6bcf7f 0%, #4cd137 100%)'
        ];
        container.style.background = colors[index];
        
        const header = document.createElement('div');
        header.className = 'mobile-circle-header';
        
        const title = document.createElement('div');
        title.className = 'mobile-circle-title';
        title.textContent = titles[index];
        title.style.color = 'white';
        
        const addBtn = document.createElement('button');
        addBtn.className = 'mobile-add-task-btn';
        addBtn.textContent = '+ Dodaj';
        addBtn.addEventListener('click', () => addMobileTask(index));
        
        header.appendChild(title);
        header.appendChild(addBtn);
        
        const taskList = document.createElement('div');
        taskList.className = 'mobile-task-list';
        taskList.dataset.circleIndex = index;
        
        // Obsługa drag & drop - dodaj też na kontener
        taskList.addEventListener('dragover', handleMobileDragOver);
        taskList.addEventListener('drop', handleMobileDrop);
        container.addEventListener('dragover', handleMobileDragOver);
        container.addEventListener('drop', handleMobileContainerDrop);
        
        container.appendChild(header);
        container.appendChild(taskList);
        mobileCirclesView.appendChild(container);
        
        // Wypełnij zadaniami
        updateMobileCircleTasks(index);
      });
      
      // Ustaw nawigację
      const navTabs = document.querySelectorAll('.mobile-nav-tab');
      navTabs.forEach(tab => {
        tab.addEventListener('click', () => {
          navTabs.forEach(t => t.classList.remove('active'));
          tab.classList.add('active');
          
          const view = tab.dataset.view;
          if (view === 'tasks') {
            mobileCirclesView.style.display = 'block';
            mobileHistoryView.style.display = 'none';
          } else {
            mobileCirclesView.style.display = 'none';
            mobileHistoryView.style.display = 'block';
            updateMobileHistory();
          }
          currentMobileView = view;
        });
      });
      
      // Obsługa przeciągania na przycisk historii
      const historyTab = document.getElementById('mobile-history-tab');
      historyTab.addEventListener('dragover', (e) => {
        e.preventDefault();
        historyTab.classList.add('drag-over');
      });
      
      historyTab.addEventListener('dragleave', () => {
        historyTab.classList.remove('drag-over');
      });
      
      historyTab.addEventListener('drop', (e) => {
        e.preventDefault();
        historyTab.classList.remove('drag-over');
        
        if (mobileDraggedTask && mobileDraggedFrom) {
          // Przenieś zadanie do historii
          const task = taskData[mobileDraggedFrom.circleIndex][mobileDraggedFrom.taskIndex];
          
          const historyTask = {
            text: task.text,
            status: task.status,
            timestamp: new Date().toISOString()
          };
          
          savedHistory.unshift(historyTask);
          
          // Usuń z oryginalnego miejsca
          taskData[mobileDraggedFrom.circleIndex].splice(mobileDraggedFrom.taskIndex, 1);
          
          // Aktualizuj widoki
          updateMobileCircleTasks(mobileDraggedFrom.circleIndex);
          updateMobileHistory();
          
          // Przełącz na widok historii
          navTabs.forEach(t => t.classList.remove('active'));
          historyTab.classList.add('active');
          mobileCirclesView.style.display = 'none';
          mobileHistoryView.style.display = 'block';
          currentMobileView = 'history';
          
          isModified = true;
        }
      });
    }

    function createMobileTaskElement(task, circleIndex, taskIndex) {
      const taskItem = document.createElement('div');
      taskItem.className = 'mobile-task-item';
      taskItem.draggable = true;
      taskItem.dataset.circleIndex = circleIndex;
      taskItem.dataset.taskIndex = taskIndex;
      
      const checkbox = document.createElement('div');
      checkbox.className = 'mobile-task-checkbox';
      checkbox.dataset.status = task.status || 0;
      updateMobileCheckboxDisplay(checkbox);
      
      checkbox.addEventListener('click', () => {
        let status = parseInt(checkbox.dataset.status);
        status = (status + 1) % 4;
        checkbox.dataset.status = status;
        updateMobileCheckboxDisplay(checkbox);
        
        // Aktualizuj dane
        if (taskData[circleIndex] && taskData[circleIndex][taskIndex]) {
          taskData[circleIndex][taskIndex].status = status;
          isModified = true;
        }
      });
      
      const text = document.createElement('div');
      text.className = 'mobile-task-text';
      text.contentEditable = true;
      text.innerHTML = task.text.replace(/\n/g, '<br>');
      
      text.addEventListener('input', () => {
        if (taskData[circleIndex] && taskData[circleIndex][taskIndex]) {
          taskData[circleIndex][taskIndex].text = text.innerHTML;
          isModified = true;
        }
      });
      
      // Obsługa Backspace dla mobile
      text.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          if (!e.shiftKey) {
            // Pozwól na normalne zachowanie Enter (nowa linia)
          }
        } else if (e.key === 'Backspace') {
          if (text.innerHTML === '' || text.innerText.trim() === '') {
            e.preventDefault();
            const taskList = taskItem.parentNode;
            const prevTask = taskItem.previousElementSibling;
            
            // Usuń zadanie z danych
            taskData[circleIndex].splice(taskIndex, 1);
            
            // Usuń element DOM
            taskItem.remove();
            
            // Zaktualizuj widok
            updateMobileCircleTasks(circleIndex);
            
            // Ustaw focus na poprzednim zadaniu jeśli istnieje
            if (prevTask) {
              const prevText = prevTask.querySelector('.mobile-task-text');
              if (prevText) {
                prevText.focus();
                // Ustaw kursor na końcu tekstu
                const range = document.createRange();
                const sel = window.getSelection();
                range.selectNodeContents(prevText);
                range.collapse(false);
                sel.removeAllRanges();
                sel.addRange(range);
              }
            }
            
            isModified = true;
          }
        }
      });
      
      const dragHandle = document.createElement('div');
      dragHandle.className = 'mobile-drag-handle';
      dragHandle.innerHTML = '≡';
      
      // Drag events
      taskItem.addEventListener('dragstart', handleMobileDragStart);
      taskItem.addEventListener('dragend', handleMobileDragEnd);
      
      taskItem.appendChild(checkbox);
      taskItem.appendChild(text);
      taskItem.appendChild(dragHandle);
      
      return taskItem;
    }

    function updateMobileCheckboxDisplay(checkbox) {
      const status = parseInt(checkbox.dataset.status);
      if (status === 0) {
        checkbox.textContent = "";
      } else if (status === 1) {
        checkbox.textContent = "";
      } else if (status === 2) {
        checkbox.innerHTML = '✓';
      } else if (status === 3) {
        checkbox.innerHTML = '✗';
      }
    }

    function updateMobileCircleTasks(circleIndex) {
      const taskList = document.querySelector(`.mobile-task-list[data-circle-index="${circleIndex}"]`);
      if (!taskList) return;
      
      taskList.innerHTML = '';
      
      if (taskData[circleIndex]) {
        taskData[circleIndex].forEach((task, taskIndex) => {
          const taskElement = createMobileTaskElement(task, circleIndex, taskIndex);
          taskList.appendChild(taskElement);
        });
      }
    }

    function addMobileTask(circleIndex, insertAt = null) {
      if (!taskData[circleIndex]) {
        taskData[circleIndex] = [];
      }
      
      const newTask = { text: "", status: 0 };
      
      if (insertAt !== null) {
        taskData[circleIndex].splice(insertAt, 0, newTask);
      } else {
        taskData[circleIndex].push(newTask);
      }
      
      updateMobileCircleTasks(circleIndex);
      isModified = true;
      
      // Focus na nowym zadaniu
      setTimeout(() => {
        const taskList = document.querySelector(`.mobile-task-list[data-circle-index="${circleIndex}"]`);
        const newTaskElement = insertAt !== null ? 
          taskList.children[insertAt] : 
          taskList.lastElementChild;
        
        if (newTaskElement) {
          const textElement = newTaskElement.querySelector('.mobile-task-text');
          if (textElement) textElement.focus();
        }
      }, 0);
    }

    function handleMobileDragStart(e) {
      mobileDraggedTask = e.target;
      mobileDraggedFrom = {
        circleIndex: parseInt(e.target.dataset.circleIndex),
        taskIndex: parseInt(e.target.dataset.taskIndex)
      };
      e.target.classList.add('dragging');
    }

    function handleMobileDragEnd(e) {
      e.target.classList.remove('dragging');
      mobileDraggedTask = null;
      mobileDraggedFrom = null;
    }

    function handleMobileDragOver(e) {
      e.preventDefault();
    }

    function handleMobileDrop(e) {
      e.preventDefault();
      e.stopPropagation();
      
      if (!mobileDraggedTask || !mobileDraggedFrom) return;
      
      const targetCircleIndex = parseInt(e.currentTarget.dataset.circleIndex);
      
      // Znajdź, gdzie upuścić zadanie
      let targetIndex = taskData[targetCircleIndex]?.length || 0;
      
      const taskElements = Array.from(e.currentTarget.children);
      for (let i = 0; i < taskElements.length; i++) {
        const rect = taskElements[i].getBoundingClientRect();
        if (e.clientY < rect.top + rect.height / 2) {
          targetIndex = i;
          break;
        }
      }
      
      // Przenieś zadanie
      const task = taskData[mobileDraggedFrom.circleIndex][mobileDraggedFrom.taskIndex];
      
      // Usuń z oryginalnego miejsca
      taskData[mobileDraggedFrom.circleIndex].splice(mobileDraggedFrom.taskIndex, 1);
      
      // Dodaj w nowym miejscu
      if (!taskData[targetCircleIndex]) {
        taskData[targetCircleIndex] = [];
      }
      taskData[targetCircleIndex].splice(targetIndex, 0, task);
      
      // Aktualizuj widoki
      updateMobileCircleTasks(mobileDraggedFrom.circleIndex);
      updateMobileCircleTasks(targetCircleIndex);
      
      isModified = true;
    }

    // Nowa funkcja do obsługi drop na kontenerze koła
    function handleMobileContainerDrop(e) {
      e.preventDefault();
      
      // Sprawdź czy drop nie jest na liście zadań
      if (e.target.classList.contains('mobile-task-list') || e.target.closest('.mobile-task-list')) {
        return;
      }
      
      if (!mobileDraggedTask || !mobileDraggedFrom) return;
      
      const targetCircleIndex = parseInt(e.currentTarget.dataset.circleIndex);
      
      // Przenieś zadanie na koniec listy
      const task = taskData[mobileDraggedFrom.circleIndex][mobileDraggedFrom.taskIndex];
      
      // Usuń z oryginalnego miejsca
      taskData[mobileDraggedFrom.circleIndex].splice(mobileDraggedFrom.taskIndex, 1);
      
      // Dodaj na koniec nowej listy
      if (!taskData[targetCircleIndex]) {
        taskData[targetCircleIndex] = [];
      }
      taskData[targetCircleIndex].push(task);
      
      // Aktualizuj widoki
      updateMobileCircleTasks(mobileDraggedFrom.circleIndex);
      updateMobileCircleTasks(targetCircleIndex);
      
      isModified = true;
    }

    function updateMobileHistory() {
      const mobileHistoryContent = document.getElementById('mobile-history-content');
      mobileHistoryContent.innerHTML = '';
      
      if (savedHistory.length === 0) {
        mobileHistoryContent.innerHTML = '<div class="history-empty">Brak zadań w historii</div>';
      } else {
        savedHistory.forEach(task => {
          const taskElement = document.createElement('div');
          taskElement.className = 'mobile-task-item';
          
          const checkbox = document.createElement('div');
          checkbox.className = 'mobile-task-checkbox';
          checkbox.dataset.status = task.status || 0;
          updateMobileCheckboxDisplay(checkbox);
          
          const text = document.createElement('div');
          text.className = 'mobile-task-text';
          text.innerHTML = task.text.replace(/\n/g, '<br>');
          
          const timestamp = document.createElement('div');
          timestamp.className = 'timestamp';
          timestamp.textContent = formatTimestamp(task.timestamp);
          timestamp.style.fontSize = '10px';
          timestamp.style.color = '#999';
          
          taskElement.appendChild(checkbox);
          taskElement.appendChild(text);
          taskElement.appendChild(timestamp);
          
          mobileHistoryContent.appendChild(taskElement);
        });
      }
    }
    // ===== KONIEC NOWYCH FUNKCJI DLA MOBILE =====

    function formatTimestamp(date) {
      const now = new Date();
      const taskDate = new Date(date);
      const diffMs = now - taskDate;
      const diffMins = Math.floor(diffMs / 60000);
      const diffHours = Math.floor(diffMs / 3600000);
      const diffDays = Math.floor(diffMs / 86400000);

      if (diffMins < 1) return "przed chwilą";
      if (diffMins < 60) return `${diffMins} min temu`;
      if (diffHours < 24) return `${diffHours} godz. temu`;
      if (diffDays < 7) return `${diffDays} dni temu`;
      
      return taskDate.toLocaleDateString('pl-PL');
    }

    // NOWA FUNKCJA: Synchronizuje szerokość wszystkich zadań w danym kole
    function syncTaskWidths(circleElement) {
        if (!circleElement) return;
        const taskListContainer = circleElement.querySelector('.task-list-container');
        if (!taskListContainer) return;
        const tasks = Array.from(taskListContainer.querySelectorAll('.task-line'));

        if (tasks.length === 0) return;

        // Krok 1: Zresetuj szerokość wszystkich zadań, aby zmierzyć ich naturalny rozmiar
        tasks.forEach(task => task.style.width = 'auto');

        // Krok 2: Znajdź maksymalną szerokość (używając scrollWidth, które mierzy całą zawartość)
        const maxWidth = Math.max(...tasks.map(task => task.scrollWidth));
        
        // Krok 3: Ustaw nową, zsynchronizowaną szerokość wszystkim zadaniom
        tasks.forEach(task => {
            task.style.width = `${maxWidth}px`;
        });
    }

    function createTaskLine(task, onChange, isHistory = false) {
      const line = document.createElement("div");
      line.className = isHistory ? "history-task" : "task-line";
      line.draggable = true;

      const checkbox = document.createElement("div");
      checkbox.className = "checkbox";
      checkbox.textContent = "◯";
      checkbox.style.color = "#333";
      checkbox.dataset.status = task.status;

      const text = document.createElement("div");
      text.className = "task-text";
      text.contentEditable = !isHistory;
      text.spellcheck = false;
      text.innerHTML = task.text;

      const history = {
        states: [task.text],
        currentIndex: 0,
        maxSize: 100,
        lastWord: ""
      };

      function addToHistory(content) {
        const words = content.split(/\s+/);
        const currentLastWord = words[words.length - 1] || "";
        
        const shouldAddToHistory = 
          history.lastWord !== currentLastWord ||
          content.endsWith(' ') !== history.states[history.currentIndex].endsWith(' ') ||
          Math.abs(content.length - history.states[history.currentIndex].length) > 1;
        
        if (shouldAddToHistory) {
          history.states = history.states.slice(0, history.currentIndex + 1);
          history.states.push(content);
          if (history.states.length > history.maxSize) {
            history.states.shift();
          } else {
            history.currentIndex++;
          }
          history.lastWord = currentLastWord;
        }
      }

      function updateCheckbox() {
        let s = parseInt(checkbox.dataset.status);
        s = (s + 1) % 4;
        checkbox.dataset.status = s;
        if (s === 0) {
          checkbox.textContent = "";
          checkbox.style.color = "#333";
        } else if (s === 1) {
          checkbox.textContent = "";
          checkbox.style.color = "#333";
        } else if (s === 2) {
          checkbox.innerHTML = '<span style="position: relative; top: -3px; left: 1px;">✓</span>';
          checkbox.style.color = "#27ae60";
        } else {
          checkbox.innerHTML = '<span style="position: relative; top: -1px;">✗</span>';
          checkbox.style.color = "#e74c3c";
        }
        onChange();
      }

      if (task.status === 1) {
          checkbox.textContent = "";
          checkbox.style.color = "#333";
        } else if (task.status === 2) {
          checkbox.innerHTML = '<span style="position: relative; top: -3px; left: 1px;">✓</span>';
          checkbox.style.color = "#27ae60";
        } else if (task.status === 3) {
          checkbox.innerHTML = '<span style="position: relative; top: -1px;">✗</span>';
          checkbox.style.color = "#e74c3c";
        } else {
          checkbox.textContent = "";
          checkbox.style.color = "#333";
        }

      checkbox.addEventListener("click", updateCheckbox);
      
      if (!isHistory) {
        if (isMobile) {
          text.addEventListener("focus", () => line.classList.add("focused"));
          text.addEventListener("blur", () => line.classList.remove("focused"));
        }

        let isUserInput = true;
        let inputTimeout;
        
        text.addEventListener("input", () => {
          if (isUserInput) {
            clearTimeout(inputTimeout);
            inputTimeout = setTimeout(() => {
              addToHistory(text.innerHTML);
            }, 100);
            
            onChange();
            // MODYFIKACJA: Synchronizuj szerokość po wpisaniu tekstu
            syncTaskWidths(line.closest('.circle'));
          }
        });

        text.addEventListener("paste", (e) => {
          e.preventDefault();
          const pastedText = (e.clipboardData || window.clipboardData).getData("text/plain");
          
          const selection = window.getSelection();
          if (!selection.rangeCount) return;
          selection.deleteFromDocument();
          selection.getRangeAt(0).insertNode(document.createTextNode(pastedText));
          selection.collapseToEnd();
          
          addToHistory(text.innerHTML);
          onChange();
          // MODYFIKACJA: Synchronizuj szerokość po wklejeniu
          syncTaskWidths(line.closest('.circle'));
        });

        let isBackspaceHeld = false;

        text.addEventListener("keydown", (e) => {
          if ((e.ctrlKey || e.metaKey) && !e.shiftKey && !e.altKey) {
            if (e.key === "z") {
              e.preventDefault();
              clearTimeout(inputTimeout);
              if (history.currentIndex > 0) {
                history.currentIndex--;
                isUserInput = false;
                text.innerHTML = history.states[history.currentIndex];
                isUserInput = true;
                const range = document.createRange();
                const selection = window.getSelection();
                range.selectNodeContents(text);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
                onChange();
                syncTaskWidths(line.closest('.circle')); // MODYFIKACJA
              }
            } else if (e.key === "y") {
              e.preventDefault();
              clearTimeout(inputTimeout);
              if (history.currentIndex < history.states.length - 1) {
                history.currentIndex++;
                isUserInput = false;
                text.innerHTML = history.states[history.currentIndex];
                isUserInput = true;
                const range = document.createRange();
                const selection = window.getSelection();
                range.selectNodeContents(text);
                range.collapse(false);
                selection.removeAllRanges();
                selection.addRange(range);
                onChange();
                syncTaskWidths(line.closest('.circle')); // MODYFIKACJA
              }
            }
          }
          
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            clearTimeout(inputTimeout);
            const parentCircle = line.closest('.circle'); // MODYFIKACJA
            const newTask = createTaskLine({ text: "", status: 0 }, onChange);
            line.parentNode.insertBefore(newTask, line.nextSibling);
            newTask.querySelector(".task-text").focus();
            syncTaskWidths(parentCircle); // MODYFIKACJA
          } else if (e.key === "Backspace") {
            if (e.repeat) {
              isBackspaceHeld = true;
            }
            
            if ((text.innerHTML === "" || text.innerText.trim() === "") && !isBackspaceHeld) {
              e.preventDefault();
              clearTimeout(inputTimeout);
              const parent = line.parentNode;
              const parentCircle = line.closest('.circle'); // MODYFIKACJA
              const previous = line.previousElementSibling;
              parent.removeChild(line);
              if (previous && previous.querySelector) {
                const input = previous.querySelector(".task-text");
                if (input) {
                  input.focus();
                  // Ustaw kursor na końcu tekstu
                  const range = document.createRange();
                  const selection = window.getSelection();
                  range.selectNodeContents(input);
                  range.collapse(false);
                  selection.removeAllRanges();
                  selection.addRange(range);
                }
              }
              onChange();
              syncTaskWidths(parentCircle); // MODYFIKACJA
            }
          }
        });

        text.addEventListener("keyup", (e) => {
          if (e.key === "Backspace") {
            isBackspaceHeld = false;
          }
        });
      }

      line.addEventListener("dragstart", (e) => {
        draggedTask = line;
        // MODYFIKACJA: Zapisz koło źródłowe, aby zaktualizować jego szerokość po upuszczeniu zadania gdzie indziej
        draggedTask.sourceCircle = line.closest('.circle'); 
        line.classList.add("dragging");
        
        const dragData = {
          text: isHistory ? text.innerHTML : text.innerHTML,
          status: checkbox.dataset.status,
          isFromHistory: isHistory
        };
        
        if (isHistory && task.timestamp) {
          dragData.timestamp = task.timestamp;
        }
        
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("taskData", JSON.stringify(dragData));
      });

      line.addEventListener("dragend", () => {
        // MODYFIKACJA: Usuń zapisaną referencję do koła źródłowego
        if (draggedTask) draggedTask.sourceCircle = null;
        draggedTask = null;
        line.classList.remove("dragging");
      });

      line.appendChild(checkbox);
      line.appendChild(text);
      
      if (isHistory && task.timestamp) {
        const timestamp = document.createElement("div");
        timestamp.className = "timestamp";
        timestamp.textContent = formatTimestamp(task.timestamp);
        line.appendChild(timestamp);
      }
      
      return line;
    }

    function updateHistoryView() {
      historyContent.innerHTML = "";
      
      if (savedHistory.length === 0) {
        historyContent.innerHTML = '<div class="history-empty">Przeciągnij tutaj zadania, aby przenieść je do historii</div>';
      } else {
        savedHistory.forEach(task => {
          const taskLine = createTaskLine(task, () => isModified = true, true);
          historyContent.appendChild(taskLine);
        });
      }
    }

    historySection.addEventListener("dragover", (e) => {
      e.preventDefault();
      historySection.classList.add("drag-over");
    });

    historySection.addEventListener("dragleave", () => {
      historySection.classList.remove("drag-over");
    });

    historySection.addEventListener("drop", (e) => {
      e.preventDefault();
      historySection.classList.remove("drag-over");
      
      if (draggedTask && !draggedTask.classList.contains("history-task")) {
        // MODYFIKACJA: Pobierz koło źródłowe PRZED usunięciem zadania
        const sourceCircle = draggedTask.closest('.circle');

        const taskData = {
          text: draggedTask.querySelector(".task-text").innerHTML,
          status: parseInt(draggedTask.querySelector(".checkbox").dataset.status),
          timestamp: new Date().toISOString()
        };
        
        savedHistory.unshift(taskData);
        draggedTask.parentNode.removeChild(draggedTask);
        
        updateHistoryView();
        
        // MODYFIKACJA: Zaktualizuj szerokości w kole, z którego zabrano zadanie
        syncTaskWidths(sourceCircle);
        isModified = true;
      }
    });

    for (let i = 0; i < 3; i++) {
      const circle = document.createElement("div");
      circle.className = "circle";

      const title = document.createElement("div");
      title.className = "circle-title";
      title.textContent = titles[i];
      circle.appendChild(title);

      const taskListContainer = document.createElement("div");
      taskListContainer.className = "task-list-container";
      circle.appendChild(taskListContainer);

      taskListContainer.addEventListener("dragover", (e) => {
        e.preventDefault();
        circle.classList.add("active");
        const dragging = document.querySelector(".dragging");
        const afterElement = Array.from(taskListContainer.querySelectorAll(".task-line"))
          .filter(el => el !== dragging)
          .find(el => {
            const box = el.getBoundingClientRect();
            return e.clientY < box.top + box.height / 2;
          });
        taskListContainer._dropTarget = afterElement;
      });

      taskListContainer.addEventListener("dragleave", () => {
        circle.classList.remove("active");
      });

      taskListContainer.addEventListener("drop", (e) => {
        circle.classList.remove("active");
        if (draggedTask) {
          const sourceCircle = draggedTask.sourceCircle; // MODYFIKACJA
          
          if (draggedTask.classList.contains("history-task")) {
            const taskDataStr = e.dataTransfer.getData("taskData");
            if (taskDataStr) {
              const taskData = JSON.parse(taskDataStr);
              const newTask = createTaskLine({
                text: taskData.text,
                status: parseInt(taskData.status)
              }, () => isModified = true);
              
              const afterElement = taskListContainer._dropTarget;
              if (afterElement) {
                taskListContainer.insertBefore(newTask, afterElement);
              } else {
                taskListContainer.appendChild(newTask);
              }
              
              const taskIndex = savedHistory.findIndex(t => (taskData.timestamp && t.timestamp === taskData.timestamp) || (t.text === taskData.text && t.status === parseInt(taskData.status)));
              if (taskIndex > -1) {
                savedHistory.splice(taskIndex, 1);
                updateHistoryView();
              }
            }
          } else {
            const afterElement = taskListContainer._dropTarget;
            if (afterElement) {
              taskListContainer.insertBefore(draggedTask, afterElement);
            } else {
              taskListContainer.appendChild(draggedTask);
            }
          }
          taskListContainer._dropTarget = null;
          isModified = true;
          
          // MODYFIKACJA: Zaktualizuj szerokości w kole docelowym i źródłowym
          syncTaskWidths(circle);
          if (sourceCircle && sourceCircle !== circle) {
              syncTaskWidths(sourceCircle);
          }
        }
      });

      taskData[i].forEach(task => {
        const taskLine = createTaskLine(task, () => isModified = true);
        taskListContainer.appendChild(taskLine);
      });

      circle.addEventListener("dblclick", (e) => {
        if (!e.target.closest('.task-line') && !e.target.closest('.circle-title')) {
          const newTask = createTaskLine({ text: "", status: 0 }, () => isModified = true);
          taskListContainer.appendChild(newTask);
          newTask.querySelector(".task-text").focus();
          syncTaskWidths(circle); // MODYFIKACJA
        }
      });

      circle.addEventListener("touchstart", (e) => {
        if (!e.target.closest('.task-line') && !e.target.closest('.circle-title')) {
          longPressTimer = setTimeout(() => {
            const newTask = createTaskLine({ text: "", status: 0 }, () => isModified = true);
            taskListContainer.appendChild(newTask);
            newTask.querySelector(".task-text").focus();
            syncTaskWidths(circle); // MODYFIKACJA
          }, longPressDuration);
        }
      });

      circle.addEventListener("touchend", () => {
        clearTimeout(longPressTimer);
      });

      carousel.appendChild(circle);
    }

    updateHistoryView();

    // MODYFIKACJA: Zsynchronizuj szerokości dla wszystkich kół po inicjalizacji
    document.querySelectorAll('.circle').forEach(syncTaskWidths);

    function saveData() {
      const data = isMobile ? taskData : [...carousel.querySelectorAll(".circle")].map(circle =>
        [...circle.querySelector(".task-list-container").querySelectorAll(".task-line")].map(line => ({
          text: line.querySelector(".task-text").innerHTML,
          status: parseInt(line.querySelector(".checkbox").dataset.status)
        }))
      );
      localStorage.setItem("taskData", JSON.stringify(data));
      localStorage.setItem("taskHistory", JSON.stringify(savedHistory));
      isModified = false;
    }

    function exportData() {
      const data = {
        taskData: isMobile ? taskData : [...carousel.querySelectorAll(".circle")].map(circle =>
          [...circle.querySelector(".task-list-container").querySelectorAll(".task-line")].map(line => ({
            text: line.querySelector(".task-text").innerHTML,
            status: parseInt(line.querySelector(".checkbox").dataset.status)
          }))
        ),
        taskHistory: savedHistory,
        exportDate: new Date().toISOString()
      };
      
      const dataStr = JSON.stringify(data, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      
      const link = document.createElement('a');
      link.href = URL.createObjectURL(dataBlob);
      link.download = `karuzela-zadan-${new Date().toISOString().slice(0,10)}.json`;
      link.click();
      
      URL.revokeObjectURL(link.href);
    }

    function importData(event) {
      const file = event.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          
          if (!data.taskData || !Array.isArray(data.taskData)) {
            alert('Nieprawidłowy format pliku');
            return;
          }
          
          localStorage.setItem("taskData", JSON.stringify(data.taskData));
          if (data.taskHistory) {
            localStorage.setItem("taskHistory", JSON.stringify(data.taskHistory));
          }
          
          location.reload();
        } catch (error) {
          alert('Błąd podczas importowania pliku: ' + error.message);
        }
      };
      
      reader.readAsText(file);
      event.target.value = '';
    }

    window.addEventListener("beforeunload", (e) => {
      if (isModified) {
        e.preventDefault();
        e.returnValue = "Masz niezapisane zmiany. Czy na pewno chcesz opuścić stronę?";
      }
    });

    function updatePositions() {
      const items = carousel.querySelectorAll(".circle");
      const circlePositions = [];

      items.forEach((circle, i) => {
        const theta = (2 * Math.PI * i) / 3 - angle;
        const x = radius * Math.cos(theta);
        const y = radius * Math.sin(theta);
        circle.style.transform = `translate(-50%, -50%) translate(${x}px, ${y}px)`;
        circlePositions.push({ circle, y });
      });

      circlePositions.sort((a, b) => a.y - b.y);

      circlePositions.forEach((data, index) => {
        data.circle.style.zIndex = 100 + index;
      });
    }

    function animate(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime;
      lastTime = timestamp;

      angle += velocity;
      velocity *= 0.95;

      if (Math.abs(velocity) < 0.001) {
        velocity = 0;
        const sectorAngle = (2 * Math.PI) / 3;
        let snappedAngle = Math.round(angle / sectorAngle) * sectorAngle;
        let diff = snappedAngle - angle;
        angle += diff * 0.1;

        if (Math.abs(diff) > 0.0001) {
          updatePositions();
          requestAnimationFrame(animate);
        } else {
          angle = snappedAngle;
          updatePositions();
          lastTime = 0;
        }
        return;
      }

      updatePositions();
      frame = requestAnimationFrame(animate);
    }

    function getAngleFromCenter(x, y) {
      const rect = carousel.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      return Math.atan2(centerY - y, x - centerX);
    }

    function startInteraction(theta, target) {
      if (target.closest('.task-text') || target.closest('.checkbox')) return;
      isDragging = true;
      lastTheta = theta;
      cancelAnimationFrame(frame);
    }

    function moveInteraction(theta) {
      if (!isDragging) return;
      let delta = theta - lastTheta;
      if (delta > Math.PI) delta -= 2 * Math.PI;
      if (delta < -Math.PI) delta += 2 * Math.PI;
      angle += delta;
      velocity = delta;
      lastTheta = theta;
      updatePositions();
    }

    function endInteraction() {
      if (isDragging) {
        isDragging = false;
        frame = requestAnimationFrame(animate);
      }
    }

    if (!isMobile) {
      carousel.addEventListener("mousedown", (e) => {
        startInteraction(getAngleFromCenter(e.clientX, e.clientY), e.target);
      });

      window.addEventListener("mousemove", (e) => {
        moveInteraction(getAngleFromCenter(e.clientX, e.clientY));
      });

      window.addEventListener("mouseup", () => {
        endInteraction();
      });

      carousel.addEventListener("touchstart", (e) => {
        if (e.touches.length === 1) {
          startInteraction(getAngleFromCenter(e.touches[0].clientX, e.touches[0].clientY), e.target);
        }
      });

      carousel.addEventListener("touchmove", (e) => {
        if (e.touches.length !== 1) return;
        moveInteraction(getAngleFromCenter(e.touches[0].clientX, e.touches[0].clientY));
        e.preventDefault();
      }, { passive: false });

      carousel.addEventListener("touchend", () => {
        endInteraction();
      });
    }

    // Wyłącz przewijanie tła dla mobile
    if (!isMobile) {
      document.body.addEventListener("touchstart", (e) => {
        if (!e.target.closest('.carousel') && 
            !e.target.closest('.circle') && 
            !e.target.closest('.save-button') &&
            !e.target.closest('.export-button') &&
            !e.target.closest('.import-button') &&
            !e.target.closest('.datetime-container') &&
            !e.target.closest('.hint') &&
            !e.target.closest('.history-section') &&
            (e.target === document.body || e.target.closest('.content-wrapper'))) {
          isBackgroundDragging = true;
          startX = e.touches[0].pageX - window.scrollX;
          startY = e.touches[0].pageY - window.scrollY;
          scrollLeft = window.scrollX;
          scrollTop = window.scrollY;
        }
      });

      document.body.addEventListener("touchmove", (e) => {
        if (isBackgroundDragging) {
          const x = e.touches[0].pageX;
          const y = e.touches[0].pageY;
          const walkX = (x - startX) * -1;
          const walkY = (y - startY) * -1;
          window.scrollTo(scrollLeft + walkX, scrollTop + walkY);
        }
      });

      document.body.addEventListener("touchend", () => {
        isBackgroundDragging = false;
      });
    }

    if (isMobile) {
      document.body.style.minWidth = '100vw';
      document.querySelector('.content-wrapper').style.minWidth = '100vw';
      initMobileView();
    } else {
      updatePositions();
    }

    function updateDateTime() {
      const now = new Date();
      const days = ['niedziela', 'poniedziałek', 'wtorek', 'środa', 'czwartek', 'piątek', 'sobota'];
      const months = ['stycznia', 'lutego', 'marca', 'kwietnia', 'maja', 'czerwca', 
                      'lipca', 'sierpnia', 'września', 'października', 'listopada', 'grudnia'];
      
      const dayName = days[now.getDay()];
      const day = now.getDate();
      const month = months[now.getMonth()];
      
      const dateString = `${dayName}, ${day} ${month}`;
      
      const hours = now.getHours().toString().padStart(2, '0');
      const minutes = now.getMinutes().toString().padStart(2, '0');
      const timeString = `${hours}:${minutes}`;
      
      const dateElement = document.getElementById('current-date');
      const timeElement = document.getElementById('current-time');
      const mobileDateElement = document.getElementById('mobile-date');
      const mobileTimeElement = document.getElementById('mobile-time');
      
      if (dateElement) dateElement.textContent = dateString;
      if (timeElement) timeElement.textContent = timeString;
      if (mobileDateElement) mobileDateElement.textContent = dateString;
      if (mobileTimeElement) mobileTimeElement.textContent = timeString;
    }

    updateDateTime();
    setInterval(updateDateTime, 1000);

    setInterval(() => {
      const timestamps = document.querySelectorAll('.history-task .timestamp');
      timestamps.forEach((timestamp, index) => {
        if (savedHistory[index] && savedHistory[index].timestamp) {
          timestamp.textContent = formatTimestamp(savedHistory[index].timestamp);
        }
      });
    }, 60000);
  </script>
</body>
</html>
